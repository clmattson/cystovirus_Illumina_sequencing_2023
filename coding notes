#what are the reads?
for i in *.fastq; do sed -n '1~4s/^@/>/p;2~4p' $i > $i.fasta; done
for i in *.fasta; do blastn -query ${i} -subject wild_cysto_refs.fasta -outfmt '6 delim=,' -max_target_seqs 1 -max_hsps 1 >> ${i}_cysto_temp_blast_out.csv; done
for i in *.fasta; do sed "s/$/,"${i}"/" ${i}_cysto_temp_blast_out.csv > ${i}_${cysto_blast_db}_blast_out.csv; done
wc -l *_cysto_temp_blast_out.csv


#assess read quality
fastqc fastqs/*.fastq --outdir fastqc-out/


#quality trim

#below code wont work for new files
#test:
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_L*};
sample=$(basename $sample_temp);
echo $sample_temp ;
echo $sample;
done
  
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp)
fastp --in1 ./fastqs/${sample}*R1*.fastq \
  --in2 ./fastqs/${sample}*R2*.fastq \
  --out1 ./trimmed_fastqs/${sample}_L001_R1_001.qtrim.fastq \
  --out2 ./trimmed_fastqs/${sample}_L001_R2_001.qtrim.fastq \
  --detect_adapter_for_pe \
  --length_required 31 --correction;
done


#remove host contamination

#build host db
bowtie2-build P_savastanoi_ref.fasta Ps_db

#align each set of reads to the host genome
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -x Ps_db -1 ./trimmed_fastqs/${sample}_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_L001_R2_001.qtrim.fastq  -S ./trimmed_host/${sample}_L001_001.qtrim.htrim.sam;
done

#sam to bam

for pair in *_L001_001.qtrim.htrim.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools view -bS ${pair} > ${sample}_L001_001.qtrim.htrim.bam;
done

#sort bam
for pair in *_L001_001.qtrim.htrim.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_L001_001.qtrim.htrim.sorted.bam -T ./samtools_temp_dir --threads 24 ${pair};
done

#remove mapped reads
#actually I think this isnt quite right, see below
for pair in *_SXX_L001_001.qtrim.htrim.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools view -b -f 4 ${pair} > ${sample}_L001_001.qhtrim.sorted.unmapped.bam
done

#so the '-f 12' flag means to keep only reads where both mates in the pair are unmapped, which is more thorough since pe reads come from 1 piece of dna
for pair in *_L001_001.qtrim.htrim.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools view -b -f 12 ${pair} > ${sample}_L001_001.qhtrim.sorted.unmapped.bam
done

#need to get filtered bam back to fastq's. sort again?
#sort bam
for pair in *_L001_001.qhtrim.sorted.unmapped.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_L001_001.qhtrim.unmapped.sorted2.bam -T ./samtools_temp_dir2 --threads 24 ${pair};
done

for pair in *_L001_001.qhtrim.unmapped.sorted2.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_L0*};
sample=$(basename $sample_temp);
samtools fastq -@ 8 ${sample}_L001_001.qhtrim.unmapped.sorted2.bam -1 ${sample}_L001_001.R1.qhtrim.unmapped.sorted2.fastq -2 ${sample}_L001_001.R2.qhtrim.unmapped.sorted2.fastq;
done

#move to final_trimmed_fastqs

#assembly
#--metaviral


spades.py --metaviral --pe1-1 final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/metaviral/${sample}_metaviral_spades_output;
done


#--rnaviral ***** worked?
for pair in final_trimmed_fastqs/*_L001_001.R1.qhtrim.unmapped.sorted2.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_L0*}; 
sample=$(basename $sample_temp); 
spades.py --rnaviral --pe1-1 final_trimmed_fastqs/${sample}_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/rnaviral/${sample}_metaviral_spades_output;
done

#do the rest after command died:
declare -a alph1=("C" "D" "E" "F" "G" "H" "I" "J")

for sample in "${alph1[@]}";
do spades.py --rnaviral --pe1-1 final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/rnaviral/${sample}_metaviral_spades_output;
done

#rename the assembly files
for dir in *_rnaviral_spades_output;  do sample="${dir:0:1}";  mv ${dir}/scaffolds.fasta ${dir}/${sample}_scaffolds.fasta;  done

#used minimap to align the assemblies to the phi6 reference segments but honestly thhe alignments dont look great. below is the basic command i used from the internet:
minimap2 -ax asm5 ref.fa asm.fa > aln.sam

#do mafft instead
#make giant file of all assemblies with phi6 S M and L at top
cat phi6_L.fasta *_rnaviral_spades_output/*_scaffolds.fasta >> L_all_whole_scaffolds.fasta
cat phi6_M.fasta *_rnaviral_spades_output/*_scaffolds.fasta >> M_all_whole_scaffolds.fasta
cat phi6_S.fasta *_rnaviral_spades_output/*_scaffolds.fasta >> S_all_whole_scaffolds.fasta

for dir in *_rnaviral_spades_output;
do sample="${dir:0:1}"; 
mafft-einsi --genafpair --adjustdirectionaccurately --maxiterate 1000 L_all_whole_scaffolds.fasta > L_all_whole_scaffolds.mafft.fasta





#ok lets align reads to RNAv assemblies

#build  db for each assembly

for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2-build ./spades/rnaviral/${sample}_rnaviral_spades_output/${sample}_scaffolds.fasta ${sample}_rnaviral_spades_assembly_DB;
done

#align each set of reads to spades rna viral spades assembly
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -x ${sample}_rnaviral_spades_assembly_DB -1 ./trimmed_fastqs/${sample}_SXX_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_SXX_L001_R2_001.qtrim.fastq  -S ./reads_to_spadesRNAV_assemblies/${sample}_SXX_L001_001.qtrim.RNAv.sam;
done

#sam to bam

for pair in *_SXX_L001_001.qtrim.RNAv.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.RNAv.bam;
done

#sort bam
for pair in *_SXX_L001_001.qtrim.RNAv.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_SXX_L001_001.qtrim.RNAv.sorted.bam -T ./samtools_temp_dir4 --threads 24 ${pair};
done

for pair in *_SXX_L001_001.qtrim.RNAv.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -b -F 4 -f 8 ${pair} > ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped1.bam
samtools view -b -F 8 -f 4 ${pair} > ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped2.bam
samtools view -b -F 12 ${pair} > ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped_both.bam
done


for pair in *_SXX_L001_001.qtrim.RNAv.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools merge ${sample}_RNAv.merged.bam ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped1.bam ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped2.bam ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped_both.bam;
done

#sort again
for pair in *_RNAv.merged.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_RNAv_merged.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${pair};
done

for pair in *_RNAv_merged.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools fastq -@ 8 ${sample}_RNAv_merged.sorted.bam -1 ${sample}_RNAv_merged_sorted_1.fastq -2 ${sample}_RNAv_merged_sorted_2.fastq;
done


#to view read to ref alignments in tablet need to convert final bam to sam
for pair in *_RNAv_merged.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -h -o ${sample}_RNAv_merged.sorted.sam ${sample}_RNAv_merged.sorted.bam;
done



OK maybe spades --rnaviral assumes something untrue about recombination or something. Idk, lets try a diff setting for assembly
#maybe isolate spades?




#Jan 2025 updates - try --meta spades instead? 

#can speed up by adding more cores to the slurm (I used 6 instead of 1 and it took like a day instead of 3 days)

for pair in final_trimmed_fastqs/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_*}; 
sample=$(basename $sample_temp); 
spades.py --meta --pe1-1 final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/meta/${sample}_meta_spades_output;
done


#srun ran out of time before it completed all the samples (~48 hrs). Complete V W and X:

#eclare -a arr=("V" "W" "X")

#for sample in "${arr[@]}";
#do spades.py --meta --pe1-1 final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/meta/${sample}_meta_spades_output;
#done


#move contigs & scaffolds files to letter namees:

for direct in *_meta_spades_output; 
do file=$(basename $direct); 
sample=${file##*/}
sample=${file%%_*}; 
mv ${sample}_meta_spades_output/contigs.fasta ${sample}_meta_spades_output/${sample}_meta_spades_contigs.fasta;
mv ${sample}_meta_spades_output/scaffolds.fasta ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta;
done

#check if major scaffolds and contigs are the same: 
for i in  */*_*_*_*.fasta; do echo $i; grep '>' $i | head -6; echo;  done
#okay looks like theyre really similar but not identical

#blast scaffolds and align reads to them.

#blasting, code adapted from the ONT code:

#gets only sample letter from assembly folder name:
for direct in *_meta_spades_output; 
do file=$(basename $direct); 
sample=${file##*/}
sample=${file%%_*}; 
#can add line here to remove contig header whitespace if necessary
#blast the current assembly against phi6 M segment reference
blastn -query ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta -subject phi6_M.fasta -outfmt '6 delim=,' -qcov_hsp_perc 20 >  ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_M_blastout.csv;
        blast_check="$(cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_M_blastout.csv)"
        if [ -n "${blast_check}" ]; then
                echo "${sample} ${blast_check} not empty"
                #makes file with scaffold names only
                awk -F"," '{print $1}' ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_M_blastout.csv > ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_M_blastout_names.txt;
                cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_M_blastout_names.txt | awk '{gsub("_","\\_",$0);$0="(?s)^>"$0".*?(?=\\n(\\z|>))"}1' | pcregrep -oM -f - ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta >> ${sample}_meta_spades_output/${sample}_meta_spades_M_scaffolds.fasta
        fi;
done

#look at hits:
for i in *_meta_spades_output/*M*scaffolds*.fasta;  do echo $i; grep '>' $i | head -6; echo; done


#S ref blast: 
for direct in *_meta_spades_output; 
do file=$(basename $direct); 
sample=${file##*/}
sample=${file%%_*}; 
#can add line here to remove contig header whitespace if necessary
#blast the current assembly against phi6 M segment reference
blastn -query ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta -subject phi6_S.fasta -outfmt '6 delim=,' -qcov_hsp_perc 20 > ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_S_blastout.csv;
        blast_check="$(cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_S_blastout.csv)"
        if [ -n "${blast_check}" ]; then
                echo "${sample} ${blast_check} not empty"
                #makes file with scaffold names only
                awk -F"," '{print $1}' ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_S_blastout.csv > ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_S_blastout_names.txt;
                cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_S_blastout_names.txt | awk '{gsub("_","\\_",$0);$0="(?s)^>"$0".*?(?=\\n(\\z|>))"}1' | pcregrep -oM -f - ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta >> ${sample}_meta_spades_output/${sample}_meta_spades_S_scaffolds.fasta
        fi;
done

for i in *_meta_spades_output/*S*scaffolds*.fasta;  do echo $i; grep '>' $i | head -6; echo; done

#L ref blast: 
for direct in *_meta_spades_output; 
do file=$(basename $direct); 
sample=${file##*/}
sample=${file%%_*}; 
#can add line here to remove contig header whitespace if necessary
#blast the current assembly against phi6 M segment reference
blastn -query ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta -subject phi6_L.fasta -outfmt '6 delim=,' -qcov_hsp_perc 20 > ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_L_blastout.csv;
        blast_check="$(cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_L_blastout.csv)"
        if [ -n "${blast_check}" ]; then
                echo "${sample} ${blast_check} not empty"
                #makes file with scaffold names only
                awk -F"," '{print $1}' ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_L_blastout.csv > ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_L_blastout_names.txt;
                cat ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds_L_blastout_names.txt | awk '{gsub("_","\\_",$0);$0="(?s)^>"$0".*?(?=\\n(\\z|>))"}1' | pcregrep -oM -f - ${sample}_meta_spades_output/${sample}_meta_spades_scaffolds.fasta >> ${sample}_meta_spades_output/${sample}_meta_spades_L_scaffolds.fasta
        fi;
done

for i in *_meta_spades_output/*L*scaffolds*.fasta;  do echo $i; grep '>' $i | head -6; echo; done


#filter out low cov scaffolds
#align reads to blast hits



#print out only cov from fasta headers:
for i in $(grep '>' A_meta_spadesfasta); do echo ${i##*_}; done

#checklist:

- scaffold length
- scaffold cov 
- reads align to scaffold? 
- sample tot reads









### okay go back and do read normalization before genome assembly!


for pair in final_trimmed_fastqs/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq;  
do file=$(basename $pair);  sample_temp=${file%%_*};  
sample=$(basename $sample_temp);  
bbnorm.sh tgt=56 max=65 in=final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq in2=final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq out=normalized_trimmed_reads/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq out2=normalized_trimmed_reads/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.bbnorm.fastq hist=normalized_trimmed_reads/${sample}_bbnorm_histogram_out;  
done

#now retry meta spades and base spades after normalizing

#first make a tmux session and do more cores (6) in the slurm command
 srun -c 6 -t 30:00:00 --mem=20000 --pty /bin/bash

#meta spades run:
for pair in normalized_trimmed_reads/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_*}; 
sample=$(basename $sample_temp); 
spades.py --meta --pe1-1 normalized_trimmed_reads/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq --pe1-2 normalized_trimmed_reads/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.bbnorm.fastq -o spades/norm_meta/${sample}_norm_meta_spades_output;
done


#regular spades run:

for pair in normalized_trimmed_reads/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_*}; 
sample=$(basename $sample_temp); 
spades.py --pe1-1 normalized_trimmed_reads/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq --pe1-2 normalized_trimmed_reads/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.bbnorm.fastq -o spades/norm_base/${sample}_norm_base_spades_output;
done


#hmm doesnt look good. lets up the target coverage for bbnorm: 

for pair in final_trimmed_fastqs/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq;  
do file=$(basename $pair);  sample_temp=${file%%_*};  
sample=$(basename $sample_temp);  
bbnorm.sh tgt=200 max=210 in=final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq in2=final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq out=normalized_trimmed_reads/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.bbnorm.fastq out2=normalized_trimmed_reads/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.bbnorm.fastq hist=normalized_trimmed_reads/${sample}_bbnorm_histogram_out;  
done







#okay and also do base spades


for pair in final_trimmed_fastqs/*_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_*}; 
sample=$(basename $sample_temp); 
spades.py --pe1-1 final_trimmed_fastqs/${sample}_SXX_L001_001.R1.qhtrim.unmapped.sorted2.fastq --pe1-2 final_trimmed_fastqs/${sample}_SXX_L001_001.R2.qhtrim.unmapped.sorted2.fastq -o spades/base/${sample}_base_spades_output;
done










#ref based???
#first lets align reads to phi6 genome to estimate coverage

#build phi6 db
bowtie2-build phi6_ref_cat.fasta phi6catDB

#align each set of reads to the phi6 genome
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -x phi6catDB -1 ./trimmed_fastqs/${sample}_SXX_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_SXX_L001_R2_001.qtrim.fastq  -S ./reads_to_phi6_ref/${sample}_SXX_L001_001.qtrim.p6cataln.sam;
done

#sam to bam
for pair in *_SXX_L001_001.qtrim.p6cataln.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.p6cataln.bam;
done

#sort bam
for pair in *_SXX_L001_001.qtrim.p6cataln.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_SXX_L001_001.qtrim.p6cataln.sorted.bam -T ./samtools_temp_dir3 --threads 24 ${pair};
done

for pair in *_SXX_L001_001.qtrim.p6cataln.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -b -F 4 -f 8 ${pair} > ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped1.bam
samtools view -b -F 8 -f 4 ${pair} > ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped2.bam
samtools view -b -F 12 ${pair} > ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped_both.bam
done


for pair in *_SXX_L001_001.qtrim.p6cataln.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools merge ${sample}_p6cataln.merged.bam ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped1.bam ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped2.bam ${sample}_SXX_L001_001.qhtrim.p6cataln.sorted.mapped_both.bam;
done

#sort again
for pair in *_p6cataln.merged.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools sort -o ${sample}_p6cataln_merged.sorted.bam -T ./samtools_temp_dir2 --threads 24 ${pair};
done

for pair in *_p6cataln_merged.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools fastq -@ 8 ${sample}_p6cataln_merged.sorted.bam -1 ${sample}_p6cataln_merged_sorted_1.fastq -2 ${sample}_p6cataln_merged_sorted_2.fastq;
done


#to view read to ref alignments in tablet need to convert final bam to sam
for pair in *_p6cataln_merged.sorted.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools view -h -o ${sample}_p6cataln_merged.sorted.sam ${sample}_p6cataln_merged.sorted.bam;
done




#made a mistake with filtering the BAM :( redo the above:

for pair in *_SXX_L001_001.qtrim.p6aln.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
#sam to bam
#samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.p6aln.bam;
#sort bam
samtools sort -o ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_SXX_L001_001.qtrim.p6aln.bam;
#get mapped reads
samtools view -b -F 4 -f 8 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped1.bam;
#samtools view -b -F 8 -f 4 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped2.bam;
samtools view -b -F 12 -f 2 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped_both.bam;
samtools merge -o ${sample}_p6aln.merged.bam ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped1.bam ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped_both.bam;
samtools sort -o ${sample}_p6aln_merged.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_p6aln.merged.bam;
samtools fastq -@ 8 ${sample}_p6aln_merged.sorted.bam -1 ${sample}_p6aln_merged_sorted_1.fastq -2 ${sample}_p6aln_merged_sorted_2.fastq;
samtools view -h -o ${sample}_p6aln_merged.sorted.sam ${sample}_p6aln_merged.sorted.bam;
echo -e "contig\tposition\tdepth" > ${sample}_p6aln.coverage;
samtools depth ${sample}_p6aln_merged.sorted.bam >> ${sample}_p6aln.coverage;
done

#they seem to look the same in Tablet???

for pair in *_SXX_L001_001.qtrim.p6Saln.sam;
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools consensus -o ${sample}_consensus.fasta --min-depth 60 ${sample}_p6Saln.merged.sorted.bam;
done





#try regular spades and --meta spades

-- 01/08/2025

module load conda/base
conda activate cysto_illumina

#hmm, maybe i shouldnt have been trying to use a concatenated reference for ref-based assembly. lets try separate segment assembly?

#build phi6 S db
bowtie2-build phi6_S.fasta phi6_S_DB

#align each set of reads to the phi6 S seg ref
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -x phi6_S_DB -1 ./trimmed_fastqs/${sample}_SXX_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_SXX_L001_R2_001.qtrim.fastq  -S ./reads_to_phi6_S/${sample}_SXX_L001_001.qtrim.p6Saln.sam;
done

#go to new sams: 
cd reads_to_phi6_S

#follow up actions:
for pair in *_SXX_L001_001.qtrim.p6Saln.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
#sam to bam
samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.p6Saln.bam;
#sort bam
samtools sort -o ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_SXX_L001_001.qtrim.p6Saln.bam;
#get mapped reads
samtools view -b -F 4 -f 8 ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.bam > ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped1.bam;
#samtools view -b -F 8 -f 4 ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.bam > ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped2.bam;
samtools view -b -F 12 -f 2 ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.bam > ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped_both.bam;
samtools merge -o ${sample}_p6Saln.merged.bam ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped1.bam ${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped_both.bam;
samtools sort -o ${sample}_p6Saln.merged.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_p6Saln.merged.bam;
samtools fastq -@ 8 ${sample}_p6Saln.merged.sorted.bam -1 ${sample}_p6Saln.merged.sorted_1.fastq -2 ${sample}_p6Saln.merged.sorted_2.fastq;
samtools view -h -o ${sample}_p6Saln.merged.sorted.sam ${sample}_p6Saln.merged.sorted.bam;
echo -e "contig\tposition\tdepth" > ${sample}_p6Saln.coverage;
samtools depth ${sample}_p6Saln.merged.sorted.bam >> ${sample}_p6Saln.coverage;
done

${sample}_SXX_L001_001.qtrim.p6Saln.sorted.mapped2.bam

#viewwed all in tabled with phi6_S ref, here are some notes: 
S seg poor coverage

A is ok frst halh depth is only like 150
C low reads overall (<1000)
D patchy
E patchy
K patchy
O patchy
P - similar to A, some low reagions but low spots are probably over 400 depth
R is ok frst like 2500 bp depth is only like 150, wayt higher depth at end
S patchy
T - similar to A and P, some low regions but low spots are probably over 400 depth, except one low region with like 20 also low overall read count (<5000)
W low overall reads <1000
X low overall reads <1000

M looks great - even, deep



#ok now lets try to get consensus files from sams. not sure if some ahve poor coverage bc phi6 isnt a close ref for them or if bc sequence data is bad

for pair in *_SXX_L001_001.qtrim.p6Saln.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
samtools consensus -o ${sample}_p6Saln_consensus.fasta --min-depth 60 ${sample}_p6Saln.merged.sorted.bam;
done

#accidentally forgot to name with 'p6Saln' (fixed above now):
#(dont need to redoo this)
for pair in *_SXX_L001_001.qtrim.p6Saln.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
mv ${sample}_consensus.fasta ${sample}_p6Saln_consensus.fasta;
done

#realign reads to new consensus seqs:

#build phi6 S consensus databases:

for pair in *_p6Saln_consensus.fasta; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2-build ${sample}_p6Saln_consensus.fasta ${sample}_p6Saln_S_consensus_DB;
done

#go back up a dir so that we can access the fastqs
cd ..

#align each set of reads to the phi6 S consensus seq:
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -x reads_to_phi6_S/${sample}_p6Saln_S_consensus_DB -1 ./trimmed_fastqs/${sample}_SXX_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_SXX_L001_R2_001.qtrim.fastq  -S ./reads_to_phi6_S_consensus/${sample}_SXX_L001_001.qtrim.Sconsenaln.sam;
done



#do i have t do the whole soort and filter thing again...? I guess probably:

#follow up actions:
for pair in *_SXX_L001_001.qtrim.Sconsenaln.sam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
#sam to bam
samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.Sconsenaln.bam;
#sort bam
samtools sort -o ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_SXX_L001_001.qtrim.Sconsenaln.bam;
#get mapped reads
samtools view -b -F 4 -f 8 ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.bam > ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.mapped1.bam;
#samtools view -b -F 8 -f 4 ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.bam > ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.mapped2.bam;
samtools view -b -F 12 -f 2 ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.bam > ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.mapped_both.bam;
samtools merge -o ${sample}_Sconsenaln.merged.bam ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.mapped1.bam ${sample}_SXX_L001_001.qtrim.Sconsenaln.sorted.mapped_both.bam;
samtools sort -o ${sample}_Sconsenaln.merged.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_Sconsenaln.merged.bam;
samtools fastq -@ 8 ${sample}_Sconsenaln.merged.sorted.bam -1 ${sample}_Sconsenaln.merged.sorted_1.fastq -2 ${sample}_Sconsenaln.merged.sorted_2.fastq;
samtools view -h -o ${sample}_Sconsenaln.merged.sorted.sam ${sample}_Sconsenaln.merged.sorted.bam;
echo -e "contig\tposition\tdepth" > ${sample}_Sconsenaln.coverage;
samtools depth ${sample}_Sconsenaln.merged.sorted.bam >> ${sample}_Sconsenaln.coverage;
done





-- end Jan 2025 edits





#align to phi6 ref with looser requirements for bowtie
#edit this to make it do the above!!!

#align each set of reads to spades rna viral spades assembly
#use bowtie2 -y mode for very sensitive or 'try very hard' to align every read
for pair in ./fastqs/*_*R1*.fastq; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
bowtie2 -p 8 -y -x ${sample}_rnaviral_spades_assembly_DB -1 ./trimmed_fastqs/${sample}_SXX_L001_R1_001.qtrim.fastq  -2 ./trimmed_fastqs/${sample}_SXX_L001_R2_001.qtrim.fastq  -S ./reads_to_p6aln_Ymode/${sample}_SXX_L001_001.qtrim.RNAv.sam;
done

for pair in *_SXX_L001_001.qtrim.p6aln.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
#sam to bam
#samtools view -bS ${pair} > ${sample}_SXX_L001_001.qtrim.p6aln.bam;
#sort bam
samtools sort -o ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_SXX_L001_001.qtrim.p6aln.bam;
#get mapped reads
samtools view -b -F 4 -f 8 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped1.bam;
#samtools view -b -F 8 -f 4 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped2.bam;
samtools view -b -F 12 -f 2 ${sample}_SXX_L001_001.qtrim.p6aln.sorted.bam > ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped_both.bam;
samtools merge ${sample}_p6aln.merged.bam ${sample}_SXX_L001_001.qhtrim.p6aln.sorted.mapped1.bam ${sample}_SXX_L001_001.qhtrim.RNAv.sorted.mapped_both.bam;
samtools sort -o ${sample}_p6aln_merged.sorted.bam -T ./samtools_temp_dir5 --threads 24 ${sample}_p6aln.merged.bam;
samtools fastq -@ 8 ${sample}_p6aln_merged.sorted.bam -1 ${sample}_p6aln_merged_sorted_1.fastq -2 ${sample}_p6aln_merged_sorted_2.fastq;
samtools view -h -o ${sample}_p6aln_merged.sorted.sam ${sample}_p6aln_merged.sorted.bam;
echo -e "contig\tposition\tdepth" > ${sample}_p6aln.coverage;
samtools depth ${sample}_p6aln_merged.sorted.bam >> ${sample}_p6aln.coverage;
done













for pair in *_SXX_L001_001.qtrim.p6aln.bam; 
#get leading sample name letter only
do sample_temp=${pair%%_*};
sample=$(basename $sample_temp);
echo -e "contig\tposition\tdepth" > ${sample}_p6aln.coverage;
samtools depth ${sample}_p6aln_merged.sorted.bam >> ${sample}_p6aln.coverage;
done

















#filter scaffolds by spades k-mer coverage, "cov" in fasta header

#remove line breaks from scaffold files
for dir in *_rnaviral_spades_output;   
do sample="${dir:0:1}"; 
sed -i ':a;N;/>/!s/\n//;ta;P;D' ${dir}/${sample}_scaffolds.fasta; 
done


#get only high cov fastas
for dir in *_rnaviral_spades_output;   
do sample="${dir:0:1}"; 
#make array of all cov values for current dir/assembly
covs_array=();
readarray covs_array < <(grep -oP '(?<=cov_)[0-9]+' ${dir}/${sample}_scaffolds.fasta"");  
#initialize empty directory to store big cov values
gt_values=();  
for value in "${covs_array[@]}"; 
  do echo "cov value =" "${value}"
  if [[ ${value} -gt 1000 ]]; 
    then echo "${sample} value is > 1000";
  gt_values+=("${value}");  
  fi; 
done; 
for gtv in "${gt_values[@]}";
  do echo "gtv =" "${gtv}"
  grep -A 1 ${gtv} ${dir}/${sample}_scaffolds.fasta >> ${sample}_highcov_scaffolds.fasta;
done
#echo "${gt_values[@]}"; 
done

#filter out only bam alignments to filtered contigs (above):
#ok 
#get list of contigs of interest (change headers to match whats in the bam files below):
for list in *_blast_contiglist.txt;
do sample_seg="${dir:0:3}";
cut -c 3- ${list} > ${sample_seg}_blast_contiglist_trimmed.txt;
done

#filter out only bam alignments to filtered contigs:
for list in *_blast_contiglist_trimmed.txt;
do sample_seg="${list:0:3}";
sample="${list:0:1}"
cat ${sample_seg}_blast_contiglist_trimmed.txt | tr "\n" " " | xargs samtools view -bh ${sample}_RNAv_merged.sorted.bam > ${sample_seg}_RNAvFILT.merged.sorted.bam;
done

#generate depth files from bams:
for list in *_blast_contiglist_trimmed.txt; do sample_seg="${list:0:3}"; sample="${list:0:1}"; echo -e "contig\tposition\tdepth" > ${sample_seg}_RNAvFILT.coverage; samtools depth ${sample_seg}_RNAvFILT.merged.sorted.bam >> ${sample_seg}_RNAvFILT.coverage; done



#ok lets align assemblies by segment

mafft-einsi --genafpair --adjustdirectionaccurately --maxiterate 1000 L_assemblies.fasta > L_assemblies_mafft.fasta







#--isolate
for pair in reads_to_phi6_ref/*_merged_sorted_1.fastq; 
do file=$(basename $pair); 
sample_temp=${file%%_*}; 
sample=$(basename $sample_temp); 
spades.py --rnaviral --pe1-1 reads_to_phi6_ref/${sample}_merged_sorted_1.fastq --pe1-2 reads_to_phi6_ref/${sample}_merged_sorted_2.fastq -o spades/isolate/${sample}_isolate_spades_output;
done



#to view






